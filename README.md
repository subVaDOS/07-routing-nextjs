Результати на память:)

Завдання вирішено неправильно (файл lib/api.ts)

Завдання не прийнято

Добре виконані аспекти:

    Усі запити axios використовують явні дженерик аргументи для забезпечення типобезпеки.
    Відповідні інтерфейси TypeScript визначені та використовуються для даних відповідей.
    Функції є асинхронними та належним чином типізовані.
    Код уникає використання any та не декларує інтерфейс Note локально.
    Усі необхідні функції API реалізовані та повертають правильні дані.

Критичні проблеми:

    Авторизаційний токен використовується непослідовно. Змінна myKey призначається з process.env.NEXT_PUBLIC_NOTEHUB_TOKEN, але всі запити axios використовують process.env.NEXT_PUBLIC_NOTES_TOKEN у заголовках. Ця непослідовність може призвести до помилок під час виконання, якщо для авторизації не застосовується правильна змінна оточення.

Остаточне рішення:

Завдання не прийнято

Завдання вирішено правильно (файл app/not-found.tsx)

Завдання прийнято

Добре виконані аспекти:

    Компонент реалізовано як функціональний компонент.
    Для неіснуючих сторінок відображається зрозуміле та зручне для користувача повідомлення.
    Компонент правильно експортовано як експорт за умовчанням.
    Використання CSS-модулів для стилізації є відповідним та добре структурованим.

Остаточне рішення:

Завдання прийнято

Завдання вирішено правильно (файл components/TagsMenu/TagsMenu.tsx)

Завдання прийнято

Добре виконані аспекти:

    Компонент використовує директиву 'use client', що забезпечує рендеринг на стороні клієнта.
    Стан dropdown чисто керується за допомогою useState React.
    Опції меню рендеряться з одного масиву, що сприяє легкості підтримки та типобезпеці.
    Навігація здійснюється за допомогою Link з Next.js, і dropdown закривається після вибору, як і потрібно.

Фінальне рішення:

Завдання було прийнято

Завдання вирішено неправильно (файл components/Header/Header.tsx)

Завдання не прийнято

Добре виконані аспекти:

    Семантичні HTML елементи використовуються доречно (<header>, <nav>, <ul>, <li>).
    Компонент Link з next/link використовується для навігації.
    Підтримується безпека типів; немає використання any або implicit any.
    Компонент структурований чітко та легко читається.

Критичні проблеми:

    Навігація для сторінок нотаток реалізована безпосередньо з Link до "/notes" замість використання компонента TagsMenu. Компонент TagsMenu не включений в заголовок.

Остаточне рішення:

Завдання не прийнято

Завдання вирішено правильно (файл app/notes/filter/[...slug]/page.tsx)

Завдання прийнято

Добре виконані аспекти:

    Компонент реалізовано як серверний компонент і використовує async функцію.
    Властивість params правильно типізовано як Promise<{ slug: string[] }> та правильно очікується.
    Значення тега витягується з масиву slug і обробляється належним чином для випадку "all".
    Дані нотаток отримуються на сервері із використанням значення тега.
    Отримані дані та тег передаються як властивості до компонента NotesClient.
    Протягом усього коду зберігається безпека типів, немає використання any або неявного any.

Остаточне рішення:

Завдання прийнято

Завдання вирішено неправильно (файл app/notes/filter/[...slug]/Notes.client.tsx)

Завдання не прийнято

Добре виконані аспекти:

    Компонент добре структурований і використовує чітке управління станом для пошуку, пагінації та модалки.
    Реалізований debounced пошук за допомогою useDebouncedCallback.
    Логіка модалки та обробники для відкриття/закриття реалізовані чітко.
    Є типізація для пропсів та змінних, немає використання any.
    Інтерфейс користувача умовно рендерить необхідні компоненти та передає відповідні пропси.

Критичні проблеми:

    Функція fetchNotes в queryFn викликається як fetchNotes(search, currentPage), але значення тегу не передається. Це означає, що нотатки не фільтруються за наданим тегом, який є необхідним пропом і має бути включеним у вибірку.
    queryKey включає тег, але фактично запит цього не використовує, що призводить до невідповідності між ключем запиту та отриманими даними.
    SearchBox передані як пропси onInputChange та onSearch, але лише один має відповідати за оновлення стану пошуку. Це може викликати плутанину або неочікувану поведінку, особливо оскільки onSearch є debounced функцією і безпосередньо не прив'язаний до події вводу.

Остаточне рішення:

Завдання не прийнято

Завдання вирішено правильно (файл app/notes/filter/layout.tsx)

Завдання прийнято

Гарно виконані аспекти:

    Компонент layout правильно реалізовано як експорт за замовчуванням.
    Props children та sidebar правильно типізовані як React.ReactNode.
    Layout відображає sidebar та основний контент поряд у чіткій структурі.
    Для стилізації використовуються CSS модулі, що вказує на гарне розділення обов'язків.

Остаточне рішення:

Завдання прийнято

Завдання вирішено правильно (файл app/notes/filter/@sidebar/default.tsx)

Завдання прийнято

Добре виконані аспекти:

    Файл правильно реекспортує компонент SidebarNotes за замовчуванням, що є стандартним та ефективним підходом до модульного компонування в структурі Next.js App Router.
    Код лаконічний і типобезпечний, без використання any або неявного any.

Остаточне рішення:

Завдання прийнято

Завдання вирішено неправильно (файл app/layout.tsx)

Завдання не прийняте

Добре виконані аспекти:

    Макет містить необхідні структури заголовка, підвалу та основного вмісту.
    TanStackProvider коректно обгортає заголовок, основний вміст і підвал.
    Шрифти та глобальні стилі налаштовані правильно.
    Анотації типів для пропсів children та modal присутні у сигнатурі функції.

Критичні проблеми:

    Проп modal визначено у сигнатурі функції, але не рендериться у жодному місці у повернутому JSX. У результаті макет не підтримує рендеринг слотів паралельного маршруту для модального вікна.

Остаточне рішення:

Завдання не прийнято

Завдання вирішено правильно (файл app/@modal/default.tsx)

Завдання прийнято

Добре виконані аспекти:

    Компонент правильно реалізовано для повернення null, що забезпечує нерендеринг контенту.
    Компонент належним чином експортований як експорт за замовчуванням.
    Файл названий та структурований відповідно до його призначення.

Остаточне рішення:

Завдання прийнято

Завдання вирішено правильно (файл app/@modal/(.)notes/[id]/page.tsx)

Завдання прийняте

Добре виконані аспекти:

    Серверний компонент правильно реалізований і типізований з params як Проміс<{ id: string }> і коректно оброблений через await.
    Дані нотатки отримуються на сервері за допомогою prefetchQuery з правильною структурою queryKey і безпечним для типів queryFn.
    HydrationBoundary і dehydrate використовуються для надання попередньо завантажених даних клієнтському компоненту.
    Не використовуються any або імпліцитні any типи.
    Клієнтський компонент рендериться всередині HydrationBoundary, як і вказано.

Остаточне рішення:

Завдання прийняте

Завдання вирішено неправильно (файл app/@modal/(.)notes/[id]/NotePreview.client.tsx)

Завдання не прийнято

Добре виконані аспекти:

    Правильне використання React Query useQuery з відповідними queryKey і queryFn.
    Коректне оброблення станів завантаження та помилок.
    Чистий і структурований рендерінг деталей нотатки в модальному вікні.
    Використання CSS-модулів для стилізації.

Критичні проблеми:

    Компонент Modal не має функції для закриття модального вікна, що є необхідним. Відсутній кнопка або механізм у відрендереному виводі для закриття модального вікна і повернення на попередню сторінку за допомогою router.back().
    Компонент не типізує свої пропси, навіть якщо наразі їх не приймає; для ясності та безпеки типу має бути присутня явна типізація.

Остаточне рішення:

Завдання не прийнято

    Створено репозиторій 07-routing-nextjs.
    При здачі роботи надаються два посилання: на вихідні файли (репозиторій) та на робочу сторінку завдання, розгорнуту на Vercel.
    Проєкт створено за допомогою Next.js (App Router).
    Усі компоненти, які не прив'язані безпосередньо до маршруту та їх частин, зберігаються в папці components, кожен — у власній папці, з файлами:

1. файл компонента з розширенням .tsx (наприклад, Header.tsx);

2. файл стилів з такою самою назвою, що й компонент, з розширенням .module.css (наприклад, Header.module.css).

   Загальні типи та інтерфейси винесені до файлу types/note.ts.
   Функції роботи з API винесені в lib/api/ у вигляді окремих модулів.
   Для HTTP-запитів використовується бібліотека axios.
   Стан запитів у CSR-компонентах керується через TanStack Query (React Query).
   Усі компоненти типізовані з використанням TypeScript.
   Код має бути відформатований за допомогою Prettier.
   Стилізація — за допомогою CSS Modules.
   У проєкті реалізована підтримка SSR та CSR, відповідно до завдання.

В цій ДЗ вам потрібно продовжувати роботу над проєктом NoteHub, зосередившись на вдосконаленні маршрутизації.

Стилі для всіх компонентів і сторінок вже створені. Скопіюй їх із цього репозиторію: https://github.com/goitacademy/react-notehub-styles/tree/hw-07. Після створення своїх сторінок і компонентів скопіюй відповідні .module.css файли у відповідні папки в /app.

Сторінка Not found

Реалізуйте у вашому застосунку окрему сторінку для обробки випадків, коли користувач потрапляє на неіснуючий маршрут. Ця сторінка має створювати наступну розмітку:

<h1 className={css.title}>404 - Page not found</h1>
<p className={css.description}>Sorry, the page you are looking for does not exist.</p>

Фільтрація нотатків за тегом в Header

Внесіть зміни у розмітку Header, додайте до нього замість посилання Notes новий компонент TagsMenu. Компонент TagsMenu має створювати наступну розмітку:

<div className={css.menuContainer}>
  <button className={css.menuButton}>
    Notes ▾
  </button>
    <ul className={css.menuList}>
    {/* список тегів */}
      <li className={css.menuItem}>
        <a href={`url до сторінки за відповідним тегом`} className={css.menuLink}>
          Назва тегу
        </a>
      </li>
    </ul>
</div>

При кліку на тег у компоненті TagsMenu має відбуватись навігація на відповідний маршрут (наприклад, /notes/filter/Work), і запускатись фільтрація нотаток за тегом. Для реалізації цієї логіки використайте catch-all маршрути в Next.js.

Обов’язково ознайомся з документацією бекенда: щоб отримати відфільтровані нотатки, вам потрібно передати тег у параметрах запиту. Якщо тег не передати, сервер поверне всі нотатки без фільтрації. Зверніть увагу: бекенд не очікує тег All — якщо вибрано фільтр "All notes", тег у запит передавати не потрібно взагалі.

Оскільки маршрут /notes більше нам не потрібен і замість нього застосовується динамічний маршрут з фільтром за тегом, то перенесіть усі файли, які опрацьовували маршрут /notes (page.tsx, Notes.client.tsx, error.tsx та файл стилів) у відповідну директорію app/notes/filter/[...slug]/ваш_файл.

Не потрібно окремо отримувати параметри маршруту як у серверному, так і в клієнтському компоненті. Достатньо один раз дістати їх у page.tsx і передати тег як пропс у Notes.client.tsx.

Паралельні маршрути для фільтрації нотаток за тегом

Створіть новий компонент SidebarNotes за шляхом app\\notes\\filter\\@sidebar. У ньому потрібно створити меню з посиланнями для фільтрації нотаток за різними тегами. Кожне посилання має вести на маршрут, де відображаються лише нотатки, що відповідають обраному тегу. Компонент має створити наступну розмітку:

  <ul className={css.menuList}>
    {/* список тегів */}
      <li className={css.menuItem}>
        <a href={`url до сторінки за відповідним тегом`} className={css.menuLink}>
          Назва тегу
        </a>
      </li>
    </ul>

Кожне посилання має вести на відповідний маршрут, що фільтрує нотатки за тегом, з форматом /notes/filter/{tag}. Наприклад, для тега "Work" це буде /notes/filter/Work. Також необхідно передбачити маршрут для перегляду всіх нотаток без фільтрації, який веде на /notes/filter/All.

Це дозволить користувачу швидко перемикатися між нотатками, що мають певний тег, і зручно фільтрувати їх, не перезавантажуючи всю сторінку. Реалізуйте це через паралельні маршрути, щоб змінювати лише ту частину сторінки, яка відповідає за відображення нотаток.

Наприклад, при натисканні на тег "Work" URL має змінюватись на /notes/filter/Work, але сама сторінка не має перезавантажуватись — лише відбудеться зміна контенту в області відображення нотаток.

Модальне вікно з деталями нотатки

Реалізуйте компонент NotePreview для попереднього перегляду однієї нотатки у модальному вікні Modal, використовуючи перехоплення маршрутів.

При переході на маршрут типу /notes/123 має відкриватися модальне вікно з деталями обраної нотатки. Основна сторінка зі списком нотаток при цьому має залишатися на фоні та не перезавантажуватись.

Реалізуйте закриття модального вікна як повернення на маршрут сторінки, з якої відкривалось модальне вікно (наприклад, /notes/filter/Work, /note/filter/All тощо).
